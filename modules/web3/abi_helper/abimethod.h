#ifndef ABIMETHOD_H
#define ABIMETHOD_H

#include <vector>

#include <core/variant/dictionary.h>
#include <core/object/class_db.h>
#include "core/object/ref_counted.h"
#include "core/string/ustring.h"
#include "core/variant/array.h"
#include "core/variant/variant.h"

#include "abiargument.h"
#include "keccak256.h"
#include "abi_util.h"

using namespace godot;

struct Field {
	String type;
    String name;
    Vector<ABIArgumentMarshaling> inputs;
    Vector<ABIArgumentMarshaling> outputs;
    String state_mutability; // "pure", "view", "nonpayable", "payable"
    bool constant; // True if function is either pure or view
    bool payable; // True if function is payable
    bool anonymous; // True if event is declared as anonymous

    // Field functions
    void unmarshal(const Dictionary &dict) {
        type = dict.get("type", "");
        name = dict.get("name", "");
        state_mutability = dict.get("stateMutability", "");
        constant = dict.get("constant", false);
        payable = dict.get("payable", false);
        anonymous = dict.get("anonymous", false);

        if (dict.has("inputs")) {
            Array inps = dict["inputs"];
            for (int i = 0; i < inps.size(); ++i) {
                Dictionary inpDict = inps[i];
                ABIArgumentMarshaling input;
                input.unmarshal(inpDict);
                inputs.push_back(input);
            }
        }

        if (dict.has("outputs")) {
            Array outs = dict["outputs"];
            for (int i = 0; i < outs.size(); ++i) {
                Dictionary outDict = outs[i];
                ABIArgumentMarshaling output;
                output.unmarshal(outDict);
                outputs.push_back(output);
            }
        }
    }
};

// FunctionType represents different types of functions a contract might have.
enum FunctionType {
    // Constructor represents the constructor of the contract.
	// The constructor function is called while deploying a contract.
    Constructor,
    // Fallback represents the fallback function.
	// This function is executed if no other function matches the given function
	// signature and no receive function is specified.
    Fallback,
    // Receive represents the receive function.
	// This function is executed on plain Ether transfers.
    Receive,
    // Function represents a normal function.
    Function
};

// Method represents a callable given a `Name` and whether the method is a constant.
// If the method is `Const` no transaction needs to be created for this
// particular Method call. It can easily be simulated using a local VM.
// For example a `Balance()` method only needs to retrieve something
// from the storage and therefore requires no Tx to be sent to the
// network. A method such as `Transact` does require a Tx and thus will
// be flagged `false`.
// Input specifies the required input parameters for this gives method.
struct ABIMethod {
    // Name is the method name used for internal representation. It's derived from
	// the raw name and a suffix will be added in the case of a function overload.
	//
	// e.g.
	// These are two functions that have the same name:
	// * foo(int,int)
	// * foo(uint,uint)
	// The method name of the first one will be resolved as foo while the second one
	// will be resolved as foo0.
    String name;
    String raw_name;  // RawName is the raw method name parsed from ABI

	// Type indicates whether the method is a
	// special fallback introduced in solidity v0.6.0
    FunctionType type;

	// StateMutability indicates the mutability state of method,
	// the default value is nonpayable. It can be empty if the abi
	// is generated by legacy compiler.
    String state_mutability;

    // Legacy indicators generated by compiler before v0.6.0
    bool constant;
    bool payable;

    ABIArguments inputs;
    ABIArguments outputs;
    String str;

	// Sig returns the methods string signature according to the ABI spec.
	// e.g.		function foo(uint32 a, int b) = "foo(uint32,int256)"
	// Please note that "int" is substitute for its canonical representation "int256"
    String sig;

	// ID returns the canonical representation of the method's signature used by the
	// abi definition to identify method names and types.
    PackedByteArray id;


    // ABIMethod functions
    ABIMethod(const String& name_, const String& raw_name_, FunctionType type_, const String& state_mutability_, bool constant_, bool payable_, const ABIArguments& inputs_, const ABIArguments& outputs_, const String& str_, const String& sig_, const PackedByteArray& id_)
        : name(name_), raw_name(raw_name_), type(type_), state_mutability(state_mutability_), constant(constant_), payable(payable_), inputs(inputs_), outputs(outputs_), str(str_), sig(sig_), id(id_) {}

	void format_output() const;

    String string(const Dictionary &dict) {
        return str;
    }

    bool is_constant() {
        return state_mutability == "view" || state_mutability == "pure" || constant;
    }

    bool is_payable() {
        return state_mutability == "payable" || payable;
    }
};


// enum FunctionType { Function, Fallback, Receive, Constructor };
// struct Argument { String Type; String Name; };
// using Arguments = Vector<Argument>;
ABIMethod* NewABIMethod(const String& name, const String& rawName, FunctionType funType, const String& mutability, bool isConst, bool isPayable, const ABIArguments& inputs, const ABIArguments& outputs);


#endif // ABIMETHOD_H
