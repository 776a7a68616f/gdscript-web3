#ifndef ABIMETHOD_H
#define ABIMETHOD_H

#include <vector>

#include <core/variant/dictionary.h>
#include <core/object/class_db.h>
#include "core/object/ref_counted.h"
#include "core/string/ustring.h"
#include "core/variant/array.h"
#include "core/variant/variant.h"

#include "abiargument.h"
#include "keccak256.h"
#include "abi_util.h"

using namespace godot;

struct Field {
	String type;
    String name;
    Vector<ABIArgumentMarshaling> inputs;
    Vector<ABIArgumentMarshaling> outputs;
    String state_mutability; // "pure", "view", "nonpayable", "payable"
    bool constant; // True if function is either pure or view
    bool payable; // True if function is payable
    bool anonymous; // True if event is declared as anonymous

    // Field functions
    void unmarshal(const Dictionary &dict) {
        type = dict.get("type", "");
        name = dict.get("name", "");
        state_mutability = dict.get("stateMutability", "");
        constant = dict.get("constant", false);
        payable = dict.get("payable", false);
        anonymous = dict.get("anonymous", false);

        if (dict.has("inputs")) {
            Array inps = dict["inputs"];
            for (int i = 0; i < inps.size(); ++i) {
                Dictionary inpDict = inps[i];
                ABIArgumentMarshaling input;
                input.unmarshal(inpDict);
                inputs.push_back(input);
            }
        }

        if (dict.has("outputs")) {
            Array outs = dict["outputs"];
            for (int i = 0; i < outs.size(); ++i) {
                Dictionary outDict = outs[i];
                ABIArgumentMarshaling output;
                output.unmarshal(outDict);
                outputs.push_back(output);
            }
        }
    }
};

// FunctionType represents different types of functions a contract might have.
enum FunctionType {
    // Constructor represents the constructor of the contract.
	// The constructor function is called while deploying a contract.
    Constructor,
    // Fallback represents the fallback function.
	// This function is executed if no other function matches the given function
	// signature and no receive function is specified.
    Fallback,
    // Receive represents the receive function.
	// This function is executed on plain Ether transfers.
    Receive,
    // Function represents a normal function.
    Function
};

// Method represents a callable given a `Name` and whether the method is a constant.
// If the method is `Const` no transaction needs to be created for this
// particular Method call. It can easily be simulated using a local VM.
// For example a `Balance()` method only needs to retrieve something
// from the storage and therefore requires no Tx to be sent to the
// network. A method such as `Transact` does require a Tx and thus will
// be flagged `false`.
// Input specifies the required input parameters for this gives method.
struct ABIMethod {
    // Name is the method name used for internal representation. It's derived from
	// the raw name and a suffix will be added in the case of a function overload.
	//
	// e.g.
	// These are two functions that have the same name:
	// * foo(int,int)
	// * foo(uint,uint)
	// The method name of the first one will be resolved as foo while the second one
	// will be resolved as foo0.
    String name;
    String raw_name;  // RawName is the raw method name parsed from ABI

	// Type indicates whether the method is a
	// special fallback introduced in solidity v0.6.0
    FunctionType type;

	// StateMutability indicates the mutability state of method,
	// the default value is nonpayable. It can be empty if the abi
	// is generated by legacy compiler.
    String state_mutability;

    // Legacy indicators generated by compiler before v0.6.0
    bool constant;
    bool payable;

    ABIArguments inputs;
    ABIArguments outputs;
    String str;

	// Sig returns the methods string signature according to the ABI spec.
	// e.g.		function foo(uint32 a, int b) = "foo(uint32,int256)"
	// Please note that "int" is substitute for its canonical representation "int256"
    String sig;

	// ID returns the canonical representation of the method's signature used by the
	// abi definition to identify method names and types.
    PackedByteArray id;


    // ABIMethod functions
    ABIMethod(const String& name_, const String& raw_name_, FunctionType type_, const String& state_mutability_, bool constant_, bool payable_, const ABIArguments& inputs_, const ABIArguments& outputs_, const String& str_, const String& sig_, const PackedByteArray& id_)
        : name(name_), raw_name(raw_name_), type(type_), state_mutability(state_mutability_), constant(constant_), payable(payable_), inputs(inputs_), outputs(outputs_), str(str_), sig(sig_), id(id_) {}

    String string(const Dictionary &dict) {
        return str;
    }

    bool is_constant() {
        return state_mutability == "view" || state_mutability == "pure" || constant;
    }

    bool is_payable() {
        return state_mutability == "payable" || payable;
    }
};


// enum FunctionType { Function, Fallback, Receive, Constructor };
// struct Argument { String Type; String Name; };
// using Arguments = Vector<Argument>;
inline ABIMethod* NewABIMethod(const String& name, const String& rawName, FunctionType funType, const String& mutability, bool isConst, bool isPayable, const ABIArguments& inputs, const ABIArguments& outputs) {
    Vector<String> types;
    Vector<String> inputNames;
    Vector<String> outputNames;

    for (const auto& input : inputs) {
        inputNames.push_back(input.type + " " + input.name);
        types.push_back(input.type);
    }

    for (const auto& output : outputs) {
        String outputName = output.type;
        if (output.name != "") {
            outputName += " " + output.name;
        }
        outputNames.push_back(outputName);
    }

    String sig;
    Vector<uint8_t> id;
    if (funType == Function) {
        // equal: sig = fmt.Sprintf("%v(%v)", rawName, strings.Join(types, ","))
        sig = rawName + "(" + join(types, ",") + ")";
    	uint8_t hash[32];
        CharString utf8_bytes = sig.utf8();

        uint8_t* strs_bytes = new uint8_t[utf8_bytes.size()];

        for (int i = 0; i < utf8_bytes.size(); ++i) {
            strs_bytes[i] = utf8_bytes[i];
        }
        int res = eth_keccak256(hash, strs_bytes, sig.size());
        if ( res < 0 ) {
            // error: TODO
            std::cout << "error in NewMethod()" << std::endl;
        }
        // use the first 4 bytes as the id
        for (int i = 0; i < 4; ++i) {
            id.push_back(hash[i]);
        }
    }

    String identity = "function " + rawName;
    switch (funType) {
        case Fallback: identity = "fallback"; break;
        case Receive: identity = "receive"; break;
        case Constructor: identity = "constructor"; break;
        default: break;
    }

    String str;
    if (mutability == "" || mutability == "nonpayable") {
        str = identity + "(" + join(inputNames, ", ") + ") returns(" + join(outputNames, ", ") + ")";
    } else {
        str = identity + "(" + join(inputNames, ", ") + ") " + mutability + " returns(" + join(outputNames, ", ") + ")";
    }

    return memnew(ABIMethod(name, rawName, funType, mutability, isConst, isPayable, inputs, outputs, str, sig, id));
}

#endif // ABIMETHOD_H
